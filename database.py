from sqlalchemy import create_engine                        #ENGINE FOR THE DATABASE
from sqlalchemy.ext.declarative import declarative_base     #BASE CLASS FOR OUR MODELS
from sqlalchemy.orm import sessionmaker                     #SESSION FOR INTERACTING WITH THE DATABASE

SQLALCHEMY_DATABASE_URL = "postgresql://postgres:admin@localhost:5432/blog_db"            #DATABASE URL FOR SQLITE, THE DATABASE FILE WILL BE CREATED IN THE CURRENT DIRECTORY

engine = create_engine(SQLALCHEMY_DATABASE_URL)         #CONNECT ARGUMENT FOR SQLITE TO ALLOW MULTIPLE THREADS

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)     #SESSIONMAKER FACTORY FUNCTION TO CREATE NEW SESSIONS, WITH AUTOCOMMIT AND AUTOFUSH DISABLED, AND BOUND TO THE ENGINE

Base = declarative_base() #BASE CLASS FOR OUR MODELS, ALL MODELS WILL INHERIT FROM THIS BASE CLASS TO GET THE FUNCTIONALITY OF SQLALCHEMY ORM

def get_db():                   #DEPENDENCY FUNCTION TO GET A DATABASE SESSION, THIS WILL BE USED IN THE ENDPOINTS TO INTERACT WITH THE DATABASE
    db = SessionLocal()         #CREATING A NEW DATABASE SESSION
    try:                        #YIELDING THE DATABASE SESSION TO THE CALLER, THIS ALLOWS US TO USE THE SAME SESSION IN THE ENDPOINTS AND ENSURE IT IS PROPERLY CLOSED AFTER USE
        yield db                #YIELDING THE DATABASE SESSION TO THE CALLER, THIS ALLOWS US TO USE THE SAME SESSION IN THE ENDPOINTS AND ENSURE IT IS PROPERLY CLOSED AFTER USE
    finally: 
        db.close()